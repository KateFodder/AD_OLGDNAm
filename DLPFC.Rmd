---
title: "DLPFC"
output: html_notebook
---
```{r}
library(knitr)
library(limma)
library(minfi)
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
library(IlluminaHumanMethylation450kmanifest)

# Epic manifest if applicable 
library(RColorBrewer)
library(missMethyl)
library(Gviz)
library(DMRcate)
library(stringr)
library(lumi)
library(sva)
library(ChAMP)
library(data.table)
library(dplyr)
library(textshape)
library("ggsci")
library("ggplot2")
library("gridExtra")
library(ggrepel)
library(readxl)
```


```{r}
targets0 = myLoad$pd
names(targets0)[1] <- paste("Sample_Name")

CellProp <- as.data.frame(CellProp)
CellProp$Basenames <- rownames(CellProp)
targets <- merge(targets0, CellProp, by.x=c("Basenames"), by.y=c("Basenames"))

DLPFC_samples <- subset(targets, Region =="DLPFC")
rownames(DLPFC_samples) <- DLPFC_samples$Sample_Name.x
names(DLPFC_samples)[2] <- paste("Sample_Name")
DLPFC_samplenames <- DLPFC_samples$Sample_Name

myNorm_DLPFC <- myNorm[,DLPFC_samplenames]
dim(myNorm_DLPFC)
```

```{r}
M_matrix_DLPFC <- beta2m(myNorm_DLPFC)
```

```{r}
DLPFC_samples$Slide <- as.character(DLPFC_samples$Slide)
DLPFC_samples$Plate <- as.factor(DLPFC_samples$Plate)

```

```{r}
champ.SVD(beta=as.data.frame(myNorm_DLPFC), pd = DLPFC_samples)
```

```{r}
DLPFC_samples <- DLPFC_samples %>% mutate(Plate = str_replace_all(Plate, " ", "_"))
DLPFC_samples0 <- DLPFC_samples[,-c(1,3,14,15,16)]
DLPFC_samples <- DLPFC_samples0
Sample_group <- factor(DLPFC_samples$Sample_Group, levels=c("Control","Alzheimer"))
```

```{r Removing age associated probes}

age <- as.numeric(DLPFC_samples$Age)

design_DLPFCage <- model.matrix(~age, data=DLPFC_samples)
dim(design_DLPFCage)

fit_DLPFCage = lmFit(M_matrix_DLPFC,design_DLPFCage)

contMatrix_age <-  makeContrasts("age", levels = design_DLPFCage)

fit2_age <- contrasts.fit(fit_DLPFCage, contMatrix_age)
fit3_age <- eBayes(fit2_age)

summary(decideTests(fit3_age, adjust.method = "fdr", p.value = 0.01))

####DMPs ###
data(probe.features.epic)
probe.genes<-subset(probe.features, probe.features$feature!="IGR")
dim(probe.genes)
load("Z:/Sao_for_Preservation/PSPnetworks/annot.RData")
annSub <- annot[match(rownames(M_matrix_DLPFC),rownames(probe.genes)),]

DMPs_age <- topTable(fit3_age,  num=Inf, coef=1, genelist=annSub)


ageProbes <- subset(DMPs_age, P.Value < 0.2)
age_probes <- ageProbes$Probe


#Removing the age associated probes 
M_matrix_DLPFC_t <- as.data.frame(t(M_matrix_DLPFC))
M_matrix_DLPFC_t = M_matrix_DLPFC_t[, !names(M_matrix_DLPFC_t) %in% age_probes]

M_matrix_DLPFC_age <- as.matrix(t(M_matrix_DLPFC_t))



```



```{r}


#factors to take into account


sex <- factor(DLPFC_samples$Sex)
age <- as.numeric(DLPFC_samples$Age)
array <- factor(DLPFC_samples$Array)
slide <- as.factor(DLPFC_samples$Slide)
plate <- as.factor(DLPFC_samples$Plate)
doubleN <- as.numeric(DLPFC_samples$DoubleN)
neuNP <- as.numeric(DLPFC_samples$NeuNP)

#Design Matrix 

design_DLPFC <- model.matrix(~0+Sample_group+neuNP+age+sex+plate, data=DLPFC_samples0)
dim(design_DLPFC)

design0 <-  model.matrix(~0+neuNP+age+sex+plate, data=DLPFC_samples0)

#SVA 

n.sv = num.sv(M_matrix_DLPFC_age, design_DLPFC, method="leek") ##returns 2 Surrogate Variables 
n.sv
svobj <- sva(M_matrix_DLPFC_age, design_DLPFC, design0, n.sv=n.sv)

designSv <- cbind(design_DLPFC, svobj$sv)

#Fit 

fit = lmFit(M_matrix_DLPFC_age, design_DLPFC)

contMatrix <- makeContrasts(Sample_groupAlzheimer-Sample_groupControl, levels = design_DLPFC)

```

```{r}
#Fit 

#fit_DLPFC = lmFit(M_matrix_DLPFC, design_DLPFC)


#contMatrix_DLPFC <- makeContrasts("Sample_groupAlzheimer-Sample_groupControl", levels = design_DLPFC)

#Checking the fit with SVD 

mAdj.fit_DLPFC    <- fit$coefficients[,-c(1:2)]

mAdj_DLPFC        <- as.matrix(M_matrix_DLPFC_age) - mAdj.fit_DLPFC %*% t(design_DLPFC[,-c(1:2)])

bAdj_DLPFC <- m2beta(mAdj_DLPFC)


rownames(DLPFC_samples0) <- DLPFC_samples0$Sample_Name


```

```{r}
champ.SVD(beta=as.data.frame(bAdj_DLPFC) , pd =DLPFC_samples0)
```

```{r}
champ.SVD(beta=as.data.frame(mAdj_DLPFC) , pd =DLPFC_samples0)
```


```{r}
fit2_DLPFC <- contrasts.fit(fit, contMatrix)
fit3_DLPFC <- eBayes(fit2_DLPFC)

summary(decideTests(fit3_DLPFC, adjust.method = "fdr", p.value = 0.05))
```


```{r}

ann450k <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)

ann450kSub_DLPFC <- ann450k[match(rownames(M_matrix_DLPFC),ann450k$Name),
                      c(1:4,12:19,24:ncol(ann450k))]

DMPs_DLPFC <- topTable(fit3_DLPFC, num=Inf, coef=1, genelist=ann450kSub_DLPFC)
```


```{r}
####WCGNA with my data 
library(WGCNA)
library(data.table)
library(dplyr)
library(textshape)
library(CoExpNets)
library(tidyr)
library(naniar)
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
library(IlluminaHumanMethylation450kmanifest)
options(stringsAsFactors = FALSE)
```

```{r}

gene_table <- DMPs_DLPFC[,c(4,13)]

gene_table  <- gene_table  %>% mutate_all(na_if,"")
gene_table2  <- na.omit(gene_table )


cpgs_list  <- gene_table2$Name

adjusted_matrix  <- as.data.frame(mAdj_DLPFC)

adjusted_matrix$cpg <- rownames(adjusted_matrix )
adjusted_matrix2  <- subset(adjusted_matrix , cpg%in%cpgs_list )


adjusted_matrix3  <- adjusted_matrix2 [,1:67]
```

```{r}

data  <- as.data.frame(adjusted_matrix3 )
dim(data )
```

```{r}
data $v <- apply(data , 1, var)

dim(data )
```

```{r}

data2  <- data [data $v >= quantile(data $v, c(.90)), ] #10% most variable probes
data3  <- data [data $v >= quantile(data $v, c(.80)), ] 
```

```{r}

datExpr0  = as.data.frame(t(data3 [,-68])); #remove variance column

datExpr0 [,1:4]
datExpr  <- as.matrix(datExpr0 )
dim(datExpr )
```

```{r Trait Matrix Creation}

#creating trait matrix from targets (used in linear regression)
datTrait1 <- as.data.frame(DLPFC_samples)
datTrait4 <-datTrait1
#making disease status etc numeric 
datTrait4$Sample_Groupn <- paste("Null")
for(i in 1:nrow(datTrait4)){
  print(i)
  if(datTrait4$Sample_Group[i] == "Control"){
    datTrait4$Sample_Groupn[i] <- paste("0")
  }
  else if(datTrait4$Sample_Group[i] == "Alzheimer"){
    datTrait4$Sample_Groupn[i] <- paste("1")
  }
}
datTrait4$Sexn <- paste("Null")
for(i in 1:nrow(datTrait4)){
  print(i)
  if(datTrait4$Sex[i] == "F"){
    datTrait4$Sexn[i] <- paste("0")
  }
  else if(datTrait4$Sex[i] == "M"){
    datTrait4$Sexn[i] <- paste("1")
  }
}
datTrait5 <- datTrait4[,-c(56)]
setnames(datTrait5, old = c("Sample_Groupn","Sexn"), new=c("Sample_Group","Sex"))
```


```{r}
gsg = goodSamplesGenes(datExpr, verbose = 3);
gsg$allOK #if returns true then all good to proceed (skip next step)
```


Load the WGCNA and other packages
```{r}
library(WGCNA)
```

The following setting is important, do not omit!
```{r}
options(stringsAsFactors = FALSE)
```


```{r}
sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9)
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);
par(mar = c(0,4,2,0))
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2)

#if outlier are detected
#Plot a line to show the cut
abline(h = 270, col = "red");

```

=====================================================================================
if outlier samples are detected
Determine cluster under the line
```{r}
clust = cutreeStatic(sampleTree, cutHeight = 260, minSize = 10)
table(clust)
```

clust 1 contains the samples we want to keep.
```{r}
keepSamples = (clust==1)
datExpr = datExpr[keepSamples, ]# no samples excluded
dim(datExpr)
```

```{r}
datTraits <- datTrait5
Samples = rownames(datExpr);
datTraits$Sample_Name <- rownames(datTraits)
traitRows = match(Samples, datTraits$Sample_Name);
datTraits = datTraits[traitRows, ];

datTraits0 <- datTraits[,c(2,9,10,11,12,13)]
datTraits0$Age <- as.numeric(datTraits0$Age)
datTraits0$DoubleN <- as.numeric(datTraits0$NeuNP)
datTraits0$Sox10P <- as.numeric(datTraits0$Sox10P)
datTraits0$NeuNP <- as.numeric(datTraits0$NeuNP)
datTraits0$Sample_Group <- as.numeric(datTraits0$Sample_Group)
datTraits0$Sex <- as.numeric(datTraits0$Sex)
#Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average")
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits0, signed = FALSE);
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits0), 
                    main = "Sample dendrogram and trait heatmap")
```


# Choose a set of soft-thresholding powers
```{r}
powers = c(c(1:10), seq(from = 12, to=20, by=2))#as per tutorial
#for signed networks acceptable to go up to max power of 30, max 15 for unsigned 
#powers = c(c(1:10), seq(from = 12, to=30, by=2))

# Call the network topology analysis function
#sft = pickSoftThreshold(datExpr, powerVector = powers, networkType = "signed", verbose = 5)
# sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5, 
#       networkType ="signed hybrid", corFnc= "bicor", corOptions=list(maxPOutliers=0.05)) #change for bicor

sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5, 
                        networkType ="signed") #if changing for bicor, 
#always use maxPOutliers=0.05 or 0.10 whenever the biweight midcorrelation is used
#https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

# Plot the results:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.80,col="red")

# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

```

```{r}
bwnet = blockwiseModules(datExpr, maxBlockSize = 20000,
                         power = 14, networkType = "signed", minModuleSize = 200,
                         deepSplit = 2,#change from 2 to 4 to detect modules that are less distinct
                         reassignThreshold = 1e-6, mergeCutHeight = 0.25,
                         numericLabels = TRUE,
                         corType = "pearson",
                         maxPOutliers = 1,
                         saveTOMs = TRUE,
                         saveTOMFileBase = "TOM-blockwise",
                         verbose = 5, loadTOM = TRUE)

```


```{r}
bwnet$colors #modules
bwnet$MEs #module eigengenes of the modules
head(bwnet)
```


```{r}
table(bwnet$colors)
# Convert labels to colors for plotting
bwModuleColors = labels2colors(bwnet$colors)
table(bwModuleColors)
# open a graphics window
sizeGrWindow(6,6)
# Plot the dendrogram and the module colors underneath for block 1
plotDendroAndColors(bwnet$dendrograms[[1]], bwModuleColors[bwnet$blockGenes[[1]]],
                    "Module colors", main = "Gene dendrogram and module colors in block 1",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
# Plot the dendrogram and the module colors underneath for block 2
plotDendroAndColors(bwnet$dendrograms[[2]], bwModuleColors[bwnet$blockGenes[[2]]],
                    "Module colors", main = "Gene dendrogram and module colors in block 2",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
# Plot the dendrogram and the module colors underneath for block 3
plotDendroAndColors(bwnet$dendrograms[[3]], bwModuleColors[bwnet$blockGenes[[3]]],
                    "Module colors", main = "Gene dendrogram and module colors in block 3",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

```


#=====================================================================================

```{r}
moduleLabels = bwnet$colors
moduleColors = labels2colors(bwnet$colors)
MEs = bwnet$MEs;
geneTree = bwnet$dendrograms;
save(MEs, moduleLabels, moduleColors, geneTree, 
     file = "networkConstruction-auto.RData")
```


#=====================================================================================

#Quantifying module-trait associations

```{r}
# Define numbers of genes and samples
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);

# Recalculate MEs with color labels
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
```


We color code each association by the correlation value:
```{r}
sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 10, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.2,
               cex.lab = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))
```

#######################################################################
#Juan's package
#######################################################################
```{r}
library(CoExpNets)
```

```{r}
#first run normal wgcna
bwnet$moduleColors = bwnet$colors

#then apply

NetK <- applyKMeans("FTCX", bwnet, datExpr, n.iterations = 20, debug = F,
                    n.debug = 500, net.type = "signed", min.exchanged.genes = 20,
                    excludeGrey = F)
```


#Quantifying module-trait associations

```{r}
# Define numbers of genes and samples

datTraits1 <- datTraits[,c(12,9,10,11,13,2,7)]
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);

MEsK = orderMEs(NetK$MEs)
moduleTraitCorK = cor(MEsK, datTraits1, use = "p");
moduleTraitPvalueK = corPvalueStudent(moduleTraitCorK, nSamples);
```


```{r}
#We color code each association by the correlation value:
sizeGrWindow(10,6)
# Will display correlations and their p-values
textMatrixK = paste(signif(moduleTraitCorK, 2), "\n(",
                    signif(moduleTraitPvalueK, 1), ")", sep = "");
dim(textMatrixK) = dim(moduleTraitCorK)
par(mar = c(6, 11, 3, 3));
# Display the correlation values within a heatmap plot
datTraits <- as.data.frame(datTraits1)
labeledHeatmap(Matrix = moduleTraitCorK,
               xLabels = names(datTraits1),
               yLabels = names(MEsK),
               ySymbols = names(MEsK),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrixK,
               setStdMargins = FALSE,
               cex.text = 0.5,
               cex.lab = 0.6,
               zlim = c(-1,1),
               main = paste("Module-trait relationships (k-means)"))
```


```{r MEs and plotting trait matrix relationships }
netcolors <- NetK$moduleColors
table(netcolors)
#Creating MEs

MEs = NetK$MEs;

#3 Relating modules to external clinical traits



#3.a Quantifying moduleâ€“trait associations



nProbes = ncol(datExpr)
nSamples = nrow(datExpr)

MEs0 = moduleEigengenes(datExpr , netcolors)$eigengenes
MEs = orderMEs(MEs0)


# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));



# Display the correlation values within a heatmap plot


# Isolate sample_group from the clinical traits
datTraits <- as.data.frame(datTraits0)
sample_group = as.data.frame(datTraits$Sample_Group);
datTraits <- as.matrix(datTraits)
names(sample_group) = "Sample_Group"
MET = orderMEs(cbind(MEs, sample_group))
sizeGrWindow(6,6);
par(cex = 1.0)
plotEigengeneNetworks(MET, "Eigengene dendrogram", marDendro = c(0,4,2,0),
                      plotHeatmaps = FALSE)

```


```{r plotting of gene sig. vs. mm AND creation of geneinfo spreadsheet}

#Gene relationship to trait and important modules: Gene Significance and Module Membership
# Define variable sample_group containing the sample_group column of datTrait

names(sample_group) = "sample_group"

modNames = substring(names(MEs), 3)

geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"))

MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples))
names(geneModuleMembership) = paste("MM", modNames, sep="")
names(MMPvalue) = paste("p.MM", modNames, sep="")

sample_group$sample_group <- as.numeric(sample_group$sample_group)

geneTraitSignificance = as.data.frame(cor(datExpr , sample_group, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));


names(geneTraitSignificance) = paste("GS.", names(sample_group), sep="");
names(GSPvalue) = paste("p.GS.", names(sample_group), sep="");

module = "purple"
column = match(module, modNames);
moduleGenes = netcolors==module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for sample_group",
                   main = paste("Module membership vs. Gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)

######Summary output of network analysis results 


library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
data(IlluminaHumanMethylation450kanno.ilmn12.hg19)
annot = getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
dim(annot)
names(annot)
probes = colnames(datExpr)

probes2annot = match(probes, annot$Name)
sum(is.na(probes2annot))


geneInfo0 = data.frame(substanceBXH = probes,
                       geneSymbol = annot$UCSC_RefGene_Name[probes2annot],
                       LocusLinkID = annot$Methyl27_Loci[probes2annot],
                       moduleColor = netcolors,
                       geneTraitSignificance,
                       GSPvalue)

###Ordering modules by their significance to sample_group 
modOrder = order(-abs(cor(MEs, sample_group, use = "p")))

# Add module membership information in the chosen order
for (mod in 1:ncol(geneModuleMembership)){
  oldNames = names(geneInfo0)
  geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
                         MMPvalue[, modOrder[mod]]);
  names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                       paste("p.MM.", modNames[modOrder[mod]], sep=""))
}
# Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance
geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.sample_group));
geneInfo = geneInfo0[geneOrder, ]

geneInfo$gene <- geneInfo$geneSymbol
geneInfo$gene <- gsub("\\;.*","", geneInfo$gene)
geneInfo <- geneInfo[,c(1,29,2:28)]



```
```{r}
module = "red"
column = match(module, modNames);
moduleGenes = netcolors==module;
sizeGrWindow(7, 7);
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = "Gene significance for sample_group",
                   main = paste("Module membership vs. Gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```


```{r}
Hubs <- chooseTopHubInEachModule(
   datExpr, 
   NetK$moduleColors, 
   omitColors = "grey", 
   power = 14, 
   type = "signed")

Hubs
```


```{r Saving the data }
datExpr_DLPFC <- datExpr
datTraits_DLPFC <- datTraits
NetK_DLPFC <- NetK
bwnet_DLPFC <- bwnet
Hubs_DLPFC <- Hubs 
geneInfo_DLPFC <- geneInfo

save(datExpr_DLPFC, datTraits_DLPFC, NetK_DLPFC, bwnet_DLPFC, Hubs_DLPFC, geneInfo_DLPFC, file = "DLPFC_NetworkData_110723.RData")
```

```{r Preparing for EWCE}
#EWCE - cell enrichment 
library(EWCE)
library(ewceData)
library(SingleCellExperiment)
library(textshape)
library(readxl)
library(ggplot2)

library(ewceData)

# Load the single cell data
ctd <- ewceData::ctd()


#Getting the list of genes we used as input to WGCNA 
background_genes <- as.data.frame(geneInfo$geneSymbol)
colnames(background_genes)[1] <- paste("Name")


bg <- background_genes$Name
bg <- as.list(strsplit(bg, ";"))
bg <- unlist(bg)


```


```{r loop to run enrichmnent in all modules of object geneInfo}

bg = geneInfo$geneSymbol
modules <- unique(geneInfo$moduleColor)
x_results_list <- list()
x_results2 <- list()
#number of modules
for(i in modules[1:11]){
  print(i)
  x <- subset(geneInfo, moduleColor == i)
  x_genes <- x[,2]
print(length(x_genes))
 #Running the enrichment 
  reps=1000
  subCellStatus=TRUE 
  x_results <- EWCE::bootstrap_enrichment_test(sct_data = ctd,
                                                sctSpecies = "mouse",
                                                genelistSpecies = "human",
                                                hits = x_genes, 
                                                reps = reps,
                                                bg=bg,
                                                annotLevel = 1)
  x_results$results$Module <- paste(i)
  x_results_list[[i]] <- x_results
  x_results2[[i]] <- x_results$results
  }

EWCE <- do.call(rbind, x_results_list)
EWCE_2 <- do.call(rbind, x_results2)



EWCE_2$list = paste(EWCE_2$Module)

print(EWCE::ewce_plot(
    total_res =EWCE_2 ,
    mtc_method = "BH"
)) 


for(i in 1:nrow(EWCE_2)){
  print(i)
  if(EWCE_2$q[i] < 0.05){
    EWCE_2$Significance[i] <- paste("Significant")
  }
  else if(EWCE_2$q[i] > 0.05){
    EWCE_2$Significance[i] <- paste("Not significant")
  }
}
EWCE_2$SD <- EWCE_2$sd_from_mean
for(i in 1:nrow(EWCE_2)){
  print(i)
  if(EWCE_2$sd_from_mean[i] >0){
    EWCE_2$SD[i] <- paste(EWCE_2$sd_from_mean[i])
  }
  else if(EWCE_2$sd_from_mean[i] < 0){
    EWCE_2$SD[i] <- paste(0)
  }
}
EWCE_2$SD <- as.numeric(EWCE_2$SD)

ggplot(EWCE_2, aes(x=Module, y=CellType, color = Significance, size = SD))+ theme_bw() +
  geom_point()+ theme(axis.text.x = element_text(angle=45, hjust=1))+ scale_color_manual(values = c("Significant" = "midnightblue","Not significant"="lightblue"))+xlab("Co-methylation modules")


```


